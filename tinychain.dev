const Params = Object.create(null, {
    // The infamous max block size.
    // bytes = 1MB
    MAX_BLOCK_SERIALIZED_SIZE: {
        value: 1000000,
        enumerable: true
    },

    // Coinbase transaction outputs can be spent after this many blocks have
    // elapsed since being mined.
    //
    // This is "100" in bitcoin core.
    COINBASE_MATURITY: {
        value: 2,
        enumerable: true
    },

    // Accept blocks timestamped as being from the future, up to this amount.
    MAX_FUTURE_BLOCK_TIME: {
        value: 60 * 60 * 2,
        enumerable: true
    },

    // The number of Belushis per coin.
    // realname COIN
    BELUSHIS_PER_COIN: {
        value: 100e6,
        enumerable: true
    },

    TOTAL_COINS: {
        value: 21000000,
        enumerable: true
    },

    // The maximum number of Belushis that will ever be found.
    MAX_MONEY: {
        get: function () {
            return this.BELUSHIS_PER_COIN * this.TOTAL_COINS;
        },
        enumerable: true
    },

    // The duration we want to pass between blocks being found, in seconds.
    // This is lower than Bitcoin's configuation (10 * 60).
    //
    // realname PowTargetSpacing
    TIME_BETWEEN_BLOCKS_IN_SECS_TARGET: {
        value: 1 * 60,
        enumerable: true
    },

    // The number of seconds we want a difficulty period to last.
    //
    // Note that this differs considerably from the behavior in Bitcoin, which
    // is configured to target difficulty periods of (10 * 2016) minutes.
    //
    // realname PowTargetTimespan
    DIFFICULTY_PERIOD_IN_SECS_TARGET: {
        value: 60 * 60 * 10,
        enumerable: true
    },

    // After this number of blocks are found, adjust difficulty.
    //
    // realname DifficultyAdjustmentInterval
    DIFFICULTY_PERIOD_IN_BLOCKS: {
        get: function () {
            return this.DIFFICULTY_PERIOD_IN_SECS_TARGET / this.TIME_BETWEEN_BLOCKS_IN_SECS_TARGET;
        },
        enumerable: true
    },

    // The number of right-shifts applied to 2 ** 256 in order to create the
    // initial difficulty target necessary for mining a block.
    INITIAL_DIFFICULTY_BITS: {
        value: 24,
        enumerable: true
    },

    // The number of blocks after which the mining subsidy will halve.
    //
    // realname SubsidyHalvingInterval
    HALVE_SUBSIDY_AFTER_BLOCKS_NUM: {
        value: 210000,
        enumerable: true
    }
});

Map.prototype.toJSON = function () {
    let obj = {};
    let keys = Array.from(this.keys()).sort();

    obj['_type'] = this.constructor.name;

    for (let key of keys) {
        obj[key] = this.get(key);
    }

    return obj;
};

/**
 * Used to represent the specific output within a transaction.
 */
class OutPoint extends Map {
    constructor(txid = '', txout_idx = 0) {
        super([
            ['txid', txid],
            ['txout_idx', txout_idx]
        ]);
    }

    get txid() {
        return this.get('txid');
    }

    get txout_idx() {
        return this.get('txout_idx');
    }
}

/**
 * Inputs to a Transaction.
 */
class TxIn extends Map {
    constructor({ to_spend = null, unlock_sig = null, unlock_pk = null, sequence = 0 }) {
        super([
            // A reference to the output we're spending. This is None for coinbase
            // transactions.
            ['to_spend', to_spend],

            // The (signature, pubkey) pair which unlocks the TxOut for spending.
            ['unlock_sig', unlock_sig],
            ['unlock_pk', unlock_pk],

            // A sender-defined sequence number which allows us replacement of the txn
            // if desired.
            ['sequence', sequence]
        ]);
    }

    get to_spend() {
        return this.get('to_spend');
    }

    get unlock_sig() {
        return this.get('unlock_sig');
    }

    get unlock_pk() {
        return this.get('unlock_pk');
    }

    get sequence() {
        return this.get('sequence');
    }
}

/**
 * Outputs from a Transaction.
 */
class TxOut extends Map {
    constructor({ value = 0, to_address = '' }) {
        super([
            // The number of Belushis this awards.
            ['value', value],
            // The public key of the owner of this Txn.
            ['to_address', to_address]
        ]);
    }

    get value() {
        return this.get('value');
    }

    get to_address() {
        return this.get('to_address');
    }
}

class UnspentTxOut extends Map {
    constructor({
        value = 0,
        to_address = '',
        txid = '',
        txout_idx = 0,
        is_coinbase = false,
        height = 0
    }) {

        super([
            ['value', value],
            ['to_address', to_address],

            // The ID of the transaction this output belongs to.
            ['txid', txid],
            ['txout_idx', txout_idx],

            // Did this TxOut from from a coinbase transaction?
            ['is_coinbase', is_coinbase],

            // The blockchain height this TxOut was included in the chain.
            ['height', height]
        ]);
    }

    get value() {
        return this.get('value');
    }

    get to_address() {
        return this.get('to_address');
    }

    get txid() {
        return this.get('txid');
    }

    get txout_idx() {
        return this.get('txout_idx');
    }

    get is_coinbase() {
        return this.get('is_coinbase');
    }

    get height() {
        return this.get('height');
    }

    get outpoint() {
        return new OutPoint(this.txid, this.txout_idx);
    }
}

/**
 * TODO:
 *  - sha256d()
 *  - serialize()
 */
class Transaction extends Map {
    constructor({ txins = [], txouts = [], locktime = null }) {
        super([
            ['txins', txins],
            ['txouts', txouts],
            ['locktime', locktime]
        ]);
    }

    get txins() {
        return this.get('txins');
    }

    get txouts() {
        return this.get('txouts');
    }

    get locktime() {
        return this.get('locktime');
    }

    get is_coinbase() {
        return this.txins.size === 1 && this.txins[0].to_spend === null;
    }

    get id() {
        return sha256d(serialize(this));
    }

    validate_basics(as_coinbase = false) {
        if (!this.txouts.length || !this.txins.length && !as_coinbase) {
            throw new TxnValidationError('Missing txouts or txins');
        }

        if (serialize(this).length > Params.MAX_BLOCK_SERIALIZED_SIZE) {
            throw new TxnValidationError('Too large');
        }

        if (this.txouts.reduce((a, b) => a + b.value) > Params.MAX_MONEY) {
            throw new TxnValidationError('Spend value too high');
        }
    }

    static create_coinbase(pay_to_addr, value, height) {
        let txin = new TxIn({
            'to_spend': null,
            'unlock_sig': bytes(height),
            'unlock_pk': null,
            'sequence': 0
        });

        let txout = new TxOut({
            'value': value,
            'pay_to_addr': pay_to_addr
        });

        return new Transaction({
            'txins': [ txin ],
            'txouts': [ txout ]
        });
    }
}

class Block extends Map {
    constructor({
        version = 0,
        prev_block_hash = '',
        merkle_hash = '',
        timestamp = 0,
        bits = 0,
        nonce = 0,
        txns = []
    }) {

        super([
            // A version integer.
            ['version', version],
            // A hash of the previous block's header.
            ['prev_block_hash', prev_block_hash],
            // A hash of the Merkle tree containing all txns.
            ['merkle_hash', merkle_hash],
            // UNIX timestamp of when this block was created.
            ['timestamp', timestamp],
            // The difficulty target; i.e. the hash of this block header must be under
            // (2 ** 256 >> bits) to consider work proved.
            ['bits', bits],
            // The value that's incremented in an attempt to get the block header to
            // hash to a value below `bits`.
            ['nonce', nonce],
            ['txns', txns]
        ]);
    }

    get version() {
        return this.get('version');
    }

    get prev_block_hash() {
        return this.get('prev_block_hash');
    }

    get merkle_hash() {
        return this.get('merkle_hash');
    }

    get timestamp() {
        return this.get('timestamp');
    }

    get bits() {
        return this.get('bits');
    }

    get nonce() {
        return this.get('nonce');
    }

    get txns() {
        return this.get('txns');
    }

    /**
     * This is hashed in an attempt to discover a nonce under the difficulty
     * target.
     */
    header(nonce = null) {
        nonce = nonce || this.nonce;
        return `${this.version}${this.prev_block_hash}${this.merkle_hash}${this.timestamped}${this.bits}${nonce}`;
    }

    get id() {
        return sha256d(this.header());
    }
}

// Chain
// ----------------------------------------------------------------------------

const genesis_block = new Block({
    'version': 0,
    'prev_block_hash': null,
    'merkle_hash': '7118894203235a955a908c0abfc6d8fe6edec47b0a04ce1bf7263da3b4366d22',
    'timestamp': 1501821412,
    'bits': 24,
    'nonce': 10126761,
    'txns': [ new Transaction({
        'txins': [ new TxIn({
            'to_spend': null,
            'unlock_sig': bytes(0),
            'unlock_pk': null,
            'sequence': 0
        }) ],
        'txouts': [ new TxOut({
            'value': 5000000000,
            'to_address': '143UVyz7ooiAv1pMqbwPPpnH4BV9ifJGFF'
        }) ],
        'locktime': null
    }) ]
});

// The highest proof-of-work, valid blockchain.
//
// realname chainActive
const active_chain = [ genesis_block ];

// Branches off of the main chain.
const side_branches = [];

// Synchronize access to the active chain and side branches.
const chain_lock = {}; /* TODO: threading.RLock() */

const orphan_blocks = [];

// Used to signify the active chain in `locate_block`.
let ACTIVE_CHAIN_IDX = 0;

// @with_lock(chain_lock)
function get_current_height() {
    return active_chain.length;
}

// Misc. utilities
// ----------------------------------------------------------------------------

/**
 * Class Mapping for deserialize
 */
const CLASSES_MAP = new Map([
    Block,
    TxIn,
    TxOut,
    Transaction,
    UnspentTxOut,
    OutPoint
].map(cls => [ cls.name, cls ]));

function bytes(o) {
    return Buffer.from(o + '', 'binary').toString('hex');
}

function serialize(obj) {
    return JSON.stringify(obj);
}

function deserialize(serialized) {

    function _type(T, args) {
        return new (CLASSES_MAP.get(T))(args);
    }

    function contents_to_objs(o) {
        if (Array.isArray(o)) {
            return o.map(function (item) {
                return contents_to_objs(item);
            });
        }

        if ('[object Object]' === {}.toString.call(o)) {
            let T = false;
            let obj = {};

            for (let [ k, v ] of Object.entries(o)) {
                if (k === '_type') {
                    T = v;
                }
                else {
                    obj[k] = contents_to_objs(v);
                }
            }

            if (T) {
                return _type(T, obj);
            }

            return obj;
        }

        return o;
    }

    return contents_to_objs(JSON.parse(serialized));
}

// console.log(serialize(genesis_block));
console.info(deserialize(serialize(genesis_block)));




















